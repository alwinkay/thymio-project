<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="0" name="STOPPED"/>
<constant value="1" name="LEFT"/>
<constant value="2" name="RIGHT"/>
<constant value="3" name="BLOCKED"/>
<constant value="4" name="HARD_TURN"/>
<constant value="300" name="EDGE"/>
<constant value="200" name="TARGET"/>
<constant value="1500" name="THRESHOLD"/>
<constant value="700" name="HARD_TURN_THRESHOLD"/>
<constant value="1" name="true"/>
<constant value="0" name="false"/>
<constant value="600" name="TURN_TIMER"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II"># -----------------------------------
# Midterm Project 
# -----------------------------------
# Group 6:
# Cole Smith-Evans 	B00903345
# Cynthia Hayes 		B01051658
# Alwin Tenkorang 	B01014380
# Nathan Ikeme 		B01059341
# -----------------------------------
var state = STOPPED
var min
var max
var mean

var canHardTurn = true

motor.left.target = 0
motor.right.target = 0

# ---------------------------------------------------------
# Events
# ---------------------------------------------------------
onevent button.forward callsub EnterLeft
onevent button.backward callsub EnterStop
onevent prox
	# horizontal sensors detect blocks
	call math.stat( prox.horizontal[0:4], min, max, mean )
	
	if state != STOPPED then
	
		# handle basic left and right turn following
		if state != HARD_TURN then 			
			if state == LEFT and prox.ground.delta[0] > prox.ground.delta[1] then callsub EnterRight
	  		else 
	  			if state == RIGHT and prox.ground.delta[0] &lt; prox.ground.delta[1] then callsub EnterLeft end
	  			end
		end
		
		# hard turn exit
		if state == HARD_TURN then
			if prox.ground.delta[0] &lt; HARD_TURN_THRESHOLD then callsub EnterRight end
			if prox.ground.delta[1] &lt; HARD_TURN_THRESHOLD then callsub EnterLeft end
		end
		
		if state == LEFT or state == RIGHT then
			# if line falls off, try to hard turn to get back on
  			if prox.ground.delta[0] > HARD_TURN_THRESHOLD and prox.ground.delta[1] > HARD_TURN_THRESHOLD then
  				if canHardTurn == true then
  					callsub EnterHardTurn
  				end
			end
  		end
	end
	
onevent timer0
	timer.period[0] = 0
	canHardTurn = true
	

# ---------------------------------------------------------
# Subroutines 
# ---------------------------------------------------------

sub EnterLeft
	state = LEFT
	canHardTurn = false
	timer.period[0] = TURN_TIMER
	motor.left.target = 0
	motor.right.target = TARGET
	
sub EnterRight
	state = RIGHT
	canHardTurn = false
	timer.period[0] = TURN_TIMER
	motor.left.target = TARGET
	motor.right.target = 0

sub EnterHardTurn
	state = HARD_TURN
	if state == LEFT then
		motor.left.target = TARGET
		motor.right.target = -TARGET
	end
	
	if state == RIGHT then
		motor.left.target = -TARGET
		motor.right.target = TARGET
	end
	
sub EnterStop
	state = STOPPED
  	motor.left.target = 0
  	motor.right.target = 0
	
	
	</node>


</network>
